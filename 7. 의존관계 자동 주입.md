>- 다양한 의존관계 주입 방법 4가지

>- 생성자 주입
   - 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법이다.
   - 지금까지 진행했던 방법이 생성자 주입임.
   - 특징은
      - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다!
      - 불변, 필수 의존관계에 사용된다!
      - 불변 : 변하지 않는것! 좋은 개발습관은 한계점이랑 제약이있어야 된다. 만약 다 열어두면 어디서 뭘 수정됐는지 알 수 없기 때문이다! 
      - 필수 : 무조건 값이 있어야됨! 생성자가 있는 것은 웬만하면 값을 다 넣어야함 문서에 null을 허용한다고 하지 않는이상은 생성자에는 웬만하면 값을 다 채워넣어야 된다고 생각한다!

  ![1](https://user-images.githubusercontent.com/102012155/174811087-d47dc594-0906-4e89-8274-c0b214837f7e.JPG)
  
   - 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동으로 주입이 된다! 물론 스프링 빈에만 해당

   ![2](https://user-images.githubusercontent.com/102012155/174811117-8f0b4299-ec4e-4bc3-9ac5-6fc640aa1d9a.JPG)

>- 수정자 주입(setter 주입)
   - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법.
   - 특징은
      - 선택, 변경 가능성이 있는 의존관계에 사용된다.
      - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

   ![3](https://user-images.githubusercontent.com/102012155/174811140-255beae9-d38a-44ce-9c1d-ae243ea33052.JPG)

   - 참고로 @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생함!
     주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정하면 된다!
   - 자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx
     라는 메서드를 통해서 값을 읽거나 수정하는 규칙을 만들었는데, 그것이 자바빈 프로퍼티 규약이다. 

>- 자바빈 프로퍼티 규약 예시는 이렇다.

   ![4](https://user-images.githubusercontent.com/102012155/174811165-9f4348da-3498-402a-932b-f1036cf359aa.JPG)

>- 필드 주입
   - 이름 그대로 필드에 바로 주입하는 방법이다.
   - 특징은
      - 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서
        테스트 하기 힘든 치명적인 단점이 있음!!
      - DI프레임워크가 없으면 아무것도 할 수 없다!
      - 사용하지 말자!!!
         - 만약 사용하더라도 애플리케이션의 실제 코드와 관계 없는 데스트 코드나
         - 스프링 설정을 목표로 하는 @Configuration같은 곳에서만 특별한 용도로 사용하자.

   ![5](https://user-images.githubusercontent.com/102012155/174811188-69efdfdc-393f-4a16-ab3e-9291d55cd789.JPG)

   - 참고로 순수한 자바 테스트 코드에는 당연히 @Autowired가 동작하지 않는다.
     @SpringBootTest처럼 스프링 컨테이너를 테스트에 통합한 경우에만 사용 가능!
   - 다음 밑에 코드와 같이 @Bean에서 파라미터에 의존관계는 자동 주입된다. 수동 등록시
     자동 등록된 빈의 의존관계가 필요할 때 문제를 해결할 수 있음!!

   ![6](https://user-images.githubusercontent.com/102012155/174811217-4ed3c7bf-2548-49a6-b0df-dc4a140aacb1.JPG)

>- 일반 메서드 주입
   - 일반 메서드를 통해서 주입 받을 수 있다.
   - 특징은
      - 한번에 여러 필드를 주입 받을 수 있음.
      - 일반적으로 잘 사용하지는 않는다.

   ![7](https://user-images.githubusercontent.com/102012155/174811248-1c558d49-0e58-40d8-b23f-069bbe24de14.JPG)

   - 참고로 당연한 이야기지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야
     동작한다! 스프링 빈이 아닌 일반 Member같은 클래스에서 @Autowired코드를 적용해도 아무 기능도
     동작하지 않는다!!

>- 옵션 처리
   - 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
     그런데 @Autowired만 사용하면 required옵션의 기본값이 true로 되어 있어서 자동 주입 대상이 없으면 오류가 발생한다!
- 자동 주입 대상을 옵션으로 처리하는 방법
   - @Autowired(required = false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출이 안된다.
   - org.springframework.lang.@Nullable: 자동 주입할 대상이 없으면 null이 입력된다
   - Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

>- 예제로 확인.

   ![8](https://user-images.githubusercontent.com/102012155/174811273-eb9f5030-5ecb-43cf-8749-09a9516b9c0a.JPG)

   - Member는 스프링 빈이 아님!
   - setNoBean1()은 @Autowired(required = false)이므로 호출 자체가 안된다!

>- 출력 결과는?

   ![9](https://user-images.githubusercontent.com/102012155/174811297-ebcc5c5b-113d-4f57-bde9-60eacd455e40.JPG)

   - @Nullable을 사용한 setNoBean2는 null이 나왔고
   - Optional<>을 사용한 setNoBean3는 Optional.empty가 나왔다
   - 참고로 @Nullable, Optional은 스프링 전반에 걸쳐서 지원된다.
     예를 들어 생성자 자동 주입에서 특정 필드에만 사용해도 된다!
     
>- 생성자 주입 선택!
   - 과거에는 수정자 주입과 필드 주입을 많이 사용했는데, 최근에는 스프링을 포함한 DI 프레임워크
     대부분이 생성자 주입을 권장한다!! 이유를 알아보자!

>- 불변
   - 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
     오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다!(불변해야 함!!)
   - 수정자 주입을 사용하면, setXxx 메서드를 public 으로 열어두어야 한다.
   - 누군가 실수로 변경할수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아님!
   - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서
     불변하게 설계할 수 있음!!

>- 누락
   - 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에 다음과 같이 수정자 의존관계인 경우

   ![10](https://user-images.githubusercontent.com/102012155/174830020-542ad281-dd7e-45c1-b5cc-815822dfd785.JPG)

   - @Autowired가 프레임 워크 안에서 동작할 때는 의존관계가 없으면 오류가 발생하지만,
     지금은 프레임워크 없이 순수한 자바 코드로만 단위 테스트를 수행하고 있다.

- 이렇게 테스트를 수행하면 실행은 됨.

   ![11](https://user-images.githubusercontent.com/102012155/174830035-83ad45aa-cdd4-476a-ba2b-096ac28ffd63.JPG)

   - 그런데 막상 실행해보면 결과는 NPE(Null Point Exception)이 발생하는데,
     memberRepository, discountPolicy 모두 의존관계 주입이 누락되었기 때문!!
   - 생성자 주입을 사용하면 다음처럼 주입 데이터를 누락 했을 때 컴파일 오류가 발생한다.
     그리고 IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있다!

   ![12](https://user-images.githubusercontent.com/102012155/174830055-a46a468b-e9e6-4fda-8764-c8af19f0c204.JPG)

>- final 키워드
   - 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 생성자에서
     혹시라도 값이 설정되지 않는 오류를 컴파일 시점에서 막아준다!

   ![13](https://user-images.githubusercontent.com/102012155/174830080-8eb7effe-3cb6-4ad7-b92e-b431632a2630.JPG)

   - 잘 보면 필수 필드인 discountPolicy에 값을 설정해야 하는데, 이 부분이 누락되었다.
     자바는 컴파일 시점에 java: variable discountPolicy might not have been initialized 오류를
     발생 시킨다!
   - 기억하자! 컴파일 오류는 세상에서 가장 빠르고, 좋은 오류다!!!
   - 참고로 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에
     final키워드를 사용할 수 없음. 오직 생성자 주입 방식만 final 키워드를 사용 가능하다!

>- 정리해보면
   - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고,
     순수한 자바 언어의 특징을 잘 살리는 방법이기도 함!
   - 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로
     부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용 가능!
   - 항상 생성자 주입을 선택하자! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택하자.
     필드 주입은 사용하지 않는게 좋다!!


>- 롬복과 최슨 트랜드
   - 막상 개발을 해보면, 대부분 다 불변이고, 그래서 다음과 같이 필드에 final 키워드를 사용하게 됨
     그런데 생성자도 만들고, 주입 받은 값을 대입하는 코드도 만드니..
     필드 주입처럼 좀 편리하게 사용하는 방법은 과연 없을까?
     한번 기본 코드를 최적화 해보자!!

 >- 기본코드

   ![14](https://user-images.githubusercontent.com/102012155/174830098-e451d177-a5ad-411c-b752-0de886b8e92d.JPG)

   - 생성자가 딱 1개만 있으면 @Autowired 생략 가능!

   ![15](https://user-images.githubusercontent.com/102012155/174830118-f9091b7e-2d38-4e34-b7ba-c2341155730d.JPG)

   - 롬복을 적용해보자.
   - 롬복 라이브러리가 제공하는 @RequiredArgsConstructor 기능을 사용하면 final이 붙은 필드를
     모아서 생성자를 자동으로 만들어준다!!!!(다음 코드에는 보이지 않지만 실체 호출 가능.)
   - 최종 결과를 보자. 정말 간결해서 놀랬다!!!

>- 최종 결과 코드

   ![16](https://user-images.githubusercontent.com/102012155/174830137-ed0505a2-ef44-4ed7-ad4d-e34dc67b3d45.JPG)

   - 최종결과 코드와 이전 코드는 완전 동일하다. 롬복이 자바의 애노테이션 프로세서라는
     기능을 이용해서 컴파일 시점에 생성자 코드를 자동으로 생성해준다. 실제 class를 열어보면
     생성자 코드가 추가되어 있는 것을 확인할 수 있다!!!
>- 정리를 해보면
   - 최근에는 생성자를 딱 1개만 두고, @Autowired를 생략하는 방법을 주로 사용한다!
     여기에 Lombok라이브러리의 @RequiredArgsConstructor와 함께 사용하면 기능은 다 제공하면서
     코드는 깔끔하게 사용이 가능하다!!!!

>- 롬복 라이브러리를 적용하는 방법은!
   - build.gradle에 라이브러리 및 환경 추가

   ![17](https://user-images.githubusercontent.com/102012155/174830150-9447fba6-7de4-4df8-b1fb-5a7508b8e85e.JPG)

   - 1. Preferences(윈도우 File => Settings) => plugin => lombok 검색 설치 실행 (재시작)
   - 2. Preferences => Annotation Processors 검색 => Enable annotation processing 체크(재시작)
   - 3. 임의의 테스트 클래스를 만들고 @Getter, @Setter 확인하면 된다!

>- 조회 빈이 2개이상이면 어떻게 될까??
   - @Autowired는 타입(Type)로 조회한다.
   
   ![18](https://user-images.githubusercontent.com/102012155/175048484-bff13797-1f4d-4021-a71d-69aa1bb12afd.JPG)

   - 타입으로 조회하기 때문에, 마치 다음 코드와 유사하게 동작한다.
     ac.getBean(DiscountPolicy.class)
   - 스프링 빈 조회에서 학습했듯이 타입으로 조회하면 선택된 빈이 2개 이상일 때 문제가 발생한다!
     DiscountPolicy의 하위 타입인 FixDiscountPolicy, RateDiscountPolicy 둘 다 스프링 빈으로 선언해보자.

   ![19](https://user-images.githubusercontent.com/102012155/175048547-148dcba9-efc3-492d-8b60-dec5bf03a5e7.JPG)

   ![20](https://user-images.githubusercontent.com/102012155/175048568-32ede521-8dfd-4f4e-ab35-c03bd1bdf3bb.JPG)

   - 그리고 이렇게 의존관계 자동 주입을 실행하면

   ![21](https://user-images.githubusercontent.com/102012155/175048583-c659737e-c4e9-417e-a06f-f4f26ea0ccf6.JPG)

   - NoUniqueBeanDefinitionException 오류가 발생함!!
   - NoUniqueBeanDefinitionException: No qualifying bean of type 
     'hello.core.discount.DiscountPolicy' available: expected single matching bean 
      but found 2: fixDiscountPolicy,rateDiscountPolicy
   - 하나의 빈을 기대했는데 FixDiscountPolicy,RateDiscountPolicy 2개가
     발견되었다고 오류메시지가 알려준다!
   - 이때 하위 타입으로 지정할 수 도 있지만 하위 타입으로 지정하는 것은 DIP를 위배하고
     유연성이 떨어진다. 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개가 있을 때
     해결이 안됨... 스프링 빈을 수동으로 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다!















